Welcome to the next lecture. I'm trying still to get hang of this audio visual stuff, so sorry about the delay. At least I found out how to turn on the lights. So today we will be a little more enlightened than the last time we ended about here in the erase section last week. So I just continue with this. You probably all have your labs by now, so you enter the basic C level and you need to code something into C You had to code something into C already, so you already encountered arrays. So some of the part would be just rehearsing. But this is a good place to start because arrays are very important. You basically need arrays or some array like containers all the time. So it's a really good idea to get yourself well acquainted with this. So arrays, as I mentioned before, are statically allocated. At least we will be using only the statically allocated arrays. It is also possible to allocate them dynamically, but dynamic allocation, dynamic memory allocation in plain C or in old C++ is somewhat tedious. So we decided to just skip it. And furthermore, you need the C and C++ only for Arduinos, mostly this this semester. So in Arduinos you won't be using dynamic allocation at all because it's somewhat impractical since the Arduinos very very limited memory. So basically we will stick with the static allocation. Static allocation means that you need to a priori, at the declaration time, specify how wide how large the array will be. So in this case I'll create an array of four elements. In this case, I create an array of three elements because this is inferred from the initialization when I explicitly state the number of elements. One important thing for arrays you need to remember right away, and you probably have from the last week, is that arrays have some base type. All the items of an array are of the same type. That's quite different from a dynamically typed languages like Python where you can have a list and you can place various data types as list items. You can mix them together. No, in C you need to get stick with single data type. You can also create multi dimensional arrays, but that's not that that is not that important. I'm using this just to demonstrate that if you use multi dimensional array it will still be alignerized in the memory, so it will be still reordered. So the all the elements of the array are sequentially stored in the memory. The important thing which will become apparent in short order when I introduce pointers is that an array is stored in a continuous block in the memory. So basically if you allocate 4 items for integers, you will allocate a block which has the size of integer multiplied by four and this is the block in the memory. A continuous block in the memory. It cannot be stored sparsely. That's one of the other, another reason why we are not introducing dynamic arrays, because if you want to relocate the dynamic array, if you want to push more items into it, you need to reallocate the memory. So you still have a continuous block somewhere else. And that's somewhat tedious if you're doing that manually and it's error prone. So let's just stick to fixed size arrays for the time being. So this was just a rehearsal from last time and let me continue with the new stuff. Another basic all right, some problem here. Another basic type that you will require for your day-to-day activities is a string. Accidentally or incidentally, strings are also arrays in C Basically it's just an array of characters. So array of the car type with small one small difference. Each string has a new character at the end. The thing is, plain C arrays don't know how large they are. Yeah, if you declare a static array like this, you can infer its size from how much bytes it allocates in the memory. If you have access to this variable, then you can somehow infer it. However, in case of strings, this information isn't stored anywhere, because string is usually represented only as a pointer to the beginning. So we need a way how to find out where the string actually ends in the memory. We know it's in continuous block, so we can just scan the memory, but we need to somehow find the end. And the programmers back in the 60s when they were designing this stuff, they decided that one way how to do this is to place an end mark at the end of the string and the end mark is the new character. By null character I mean a character which casts to 0 integer 0, not the 0 character. So there is a difference between null character and 0 digit character, right? Because if you cast it to int, this will be really zero. What will this be if you cast it to int? Who remembers esquitable from from heart? Just just curious, somebody knows that You don't have to know. You really don't have to memorize it. Just just no, incidentally, it's 48, but you don't really have to remember that. If you don't believe me, just look up the Esky table and you can find out the 0 digit and you will turn it into 48. OK, so these are these, This is how strings work. This is how the strings are. You can write strings by using double quotes. And if you do this literal will actually allocate a memory for how many bytes exactly? Because there are 5 letters here and we need one extra character for the ending 0. So this will look exactly like this in the memory. OK, if you want to find out how many characters are there, you really need to go from the beginning and scan each character until you find the 0 character and then you just happen to know how many characters you have counted. OK by the way, you can also declare an array of characters. Actually, these two are quite similar, right? Declaratively they are identical, they are just different identifiers and you can initialize it using the array initializer. But beware, this initializer doesn't take into account the ending 0. So if you really want to create an array of characters for some other reasons, you can. But beware there is no ending 0. So if you incidentally try to convert this into a string, it will work technically, but without the ending 0. So if you try to access it using regular C functions like string line Sutherland which which counts counts how many characters are there, it will it might run forever or it might run into memory which is not allocated because there is no termination character which would stop it. So beware when you're trying to convert arrays into strings, it's better to stick with one or the other depending on what you want to, what you want to do. OK, just a side note, we are talking about arrays. We are talking about base types and things like that. There is one piece of information I would like to give you right away. Actually, we get back to this in in the memory layout when we will talk about memory and memory allocation and stuff like that. But this is very important. So I'm giving it to right away and you just refresh it later. So the information I'm giving you right now is that if you have a type which takes X bytes in memory, it has to be placed in the memory. So the address where this element starts is divisible by X. In other words, divisible means that if you divide it, the modulo the reminder will be 0, right? So in other words, if you take like a 32 bit integer which takes 4 bytes in the memory, it must be placed on an address, it must start on an address that is divisible by 4. Actually this is like a thing that's enforced that's required by hardware because hardware specifies this. If you take a regular CPU, most of the architectures of the day will just tell you this must be done, otherwise it just blow up in your face. I I mean like in a software manner, not in a hardware manner. So you really need to do that, otherwise the code wouldn't work at all. And some older architectures tend to, let's say some mitigations in the hardware so they can load data which are misaligned, which are not properly aligned, but it takes longer, so it takes some extra memory operations, etcetera. So it's always a good idea to do do that. And C compiler enforces this, C compiler knows this and does this for you. However, sometimes you need to be cautioned because it has some side effects that you need to be aware of. Just to clarify what I mean by the alignment. So here are three examples of three values which we have stored somewhere in the memory. And for some reasons, because for instance they were declared as a sequence of variables, the compiler decided to place them one after another. And incidentally, the compiler was able to do that because the character actually character is easy. Character or byte, they are easy because they take one byte. So every every address is divisible by one, right? Everything is divisible. Every natural number is divisible by 1. So we don't have to bother where the character will be. That's one of the benefits of strings. Also, you can allocate strings everywhere because they are made of characters. However, when we take an integer, in this case 32 bit integer into account, we need to make sure that this integer is aligned to four bytes. And if if you bear with me, you can just take this address and divide it by 4 in your calculators. For for instance. Then you find out that this number is really indeed divisible by 4. So the integer can start here and double, which takes 64 byte bits. Sorry, 8 bytes must be placed on an address which is divisible by 8. This is much more simple because 140 in hexa is is obviously divisible by 16 because it has a 0 here, right? We have a zero and it's 16 base math. So 0 means it's divisible by 16. So if it's divisible by 16, it must be divisible by 8 as well. So this is how we aligned values in the memory and why it's important will become apparent in short order when I talk about structures. Structures is the second most important data structure or data type compose data type in C So we have arrays for most cases, but sometimes you need to aggregate different types of values or named values. So basically it's also a collection of items. Similarly like array. But unlike an array, these items are not numbered, are not indexed from zero, but they are named. So we have a name, we have a identifier for each field in the structure. That's the first difference. And the second difference, perhaps the more important one, is that each field can have a different type. So you can mix types in the data structure, in the structures and it's fine. It's, it's designed to do that. So let me give you an example. We have a 2 dimensional point in a grid, not in a continuous space in a grid. So we use integers to index its position XY. And these two two indices obviously are logically tied together because they both belong to the same point. So in this case it's a very good idea to create a structure for them, because structures are designed to somehow bound together things that are logically designed to be together. In this case, 22 indices of the same point are logically should should be logically together. By the way, sometimes you can you can use other approaches how to do deal with this, but this is like the rule of thumb approach. If you have things that are tend to be together, it's a good idea to put them into one structure. If you're doing something very advanced, like in high performance computing, this doesn't have to hold, but for the beginners it's the best way how to how to deal with data. The important thing I'm trying to show here is that the the structures need to employ some additional measures regarding the alignment of the internal things. Because normally items, the fields in the structure will also be aligned in the memory one after another, and the C will preserve the order of declaration. So if you say this structure has X and then Y, then X will precede Y in the memory. That's a rule. OK, so if I declare a structure which has character C, double D and integer I. I'm sorry for the lack of imagination. I just want to give you a quick example so that you can infer the type from the name of the field. OK so in this case we have 3 fields of different types and they need to be laid down in this order. So C must come first, then must be D and then must be I. Unfortunately, if the beginning of the structure is aligned in the memory and it and it usually has to be, then C will probably be on an address which will be divisible by 8 or 16 or something like that. So if you want to place double properly in memory, you cannot place it immediately after C because if the beginning of the structure was aligned, then the place immediately after C will be aligned plus one, which is definitely not divisible by 8, probably not divisible by two. So you cannot just place it there. What the C what the C compiler does is that it creates additional padding. It just creates an empty space. Nothing will be there, just a spare space where no data will be stored. And the D field, which is a double will be shifted so it's aligned with the next alignable address. So it's aligned to 8. OK fortunately for us I is integer and integer is usually smaller in this case. In this example it's 32 bit, I mean 4 bytes wide, so it's smaller than the double. And luckily for us, if we have A8 byte word on an 8 byte alignment, the next position will start at the 16 byte alignment, which is also divisible by 4, so we can immediately after the place I. So the only padding will be will be. Here there is also an additional padding added at the end because the structure must be aligned externally to the largest item inside. We get to that later when we talk about the memory. This is just some things that you need to know that there is a big difference between array and structures in the memory layout. Because structure can be padded while the array is always compact. We don't have to pad anything in array because all the types are the same, so there are no gaps that there shouldn't be any gaps if the beginning is aligned. Just a technical detail, syntactical detail. If you're declaring a structure, it's quite easy. You just use the struct word and in the block of the structure you just list all the fields that are in the structure. When you do afterwards you can use the name of the identifier of the structure, which is in this case point 2D as a regular data type. So when I want to create a variable which holds this point, I just declare this variable using the point 2D as a as a regular data type as here I'm declaring integers. So here I'm declaring point 2D variable OK and accessing the internal property in the internal fields is done using the dot notation. So you just write the the array sorry sorry sorry. The variable that holds the the structure dot the field and this together acts as a variable. So you are accessing one like one Part 1 field of a larger structure like this. OK, so those are structures. Actually most of the stuff you will be doing, at least in this semester, will be handled in arrays and structures. So we don't need any more complex data types. In the end I will give you a glimpse on classes which are like extended structures which interconnect the data with the code, but you don't have to use them if you don't really want to. However, we still need a few things, a few additional things to make all stuff work. So now I'm now I'll be like skipping from a topic to topic for a while because we need to cover few distant issues. First one is constants. We already declared times, we know what variables are, but sometimes we need to create a constant, which means like something that doesn't change over time. The most simple constant in C is just a constant which which is created by prefixing a variable declaration with construction. Basically you can imagine this as a variable which cannot be changed over time. Why is this important? There it's, it's actually quite important if you're doing something more elaborate because you are telling the compiler this won't change. And that's important information for the compiler because when it doesn't change, it can be optimized. For instance, this value can be easily cached in a register if need be and and it will, it won't ever change because this, this variable cannot change. So it's it's always the same, it's always 42, OK. However, this is really like a variable. So you can take an address of this variable, it lives somewhere in the memory, etcetera. C++, Modern C++ offers a more elaborate way how to declare constants using a constant. Know that there is only slight difference, this is cons, this is cons. The behaviour is much more different from the terms how the things are from the perspective how things are compiled. So in this case, this value, this this variable is inlined during compilation if possible. What does it mean? It it means that it replaces all the occurrences of this variable everywhere in the code with this value. So it kind of integrates the value directly into the code. Now you can, you can think about why, why we need that? Why don't we put the 42 in the code right away? OK, There are many reasons. If you haven't read the Unforgivable Curse 2, I think it is. Then if actually, if you read the, the reasons for Unforgivable Curse 2 already, then you know the reasons. And the most importantly, it's much more readable if you know what what the 42 means. If you know it's the answer to the question of life and universe and everything, then you can just name it so that everybody who reads it knows that you mean, that's the, that's the magical number. That's the that's the answer. It's not size of my shoes, it's not my age. It's not anything remotely related to anything except it's the answer. So everybody knows what what what that means. And the second reason is that if for whatever reason you want to change this value in the future and you just happen to integrate it all over your code, then you need to find all the occurrences in your code and change the variable. Change the value, Sorry. So that might be a bad thing. Yeah, I know this answer will never change. We we know that if you, if you read the book that you know, you know this won't change. But there are other examples where the variable where the value of this constant might change, like a pin number. You have an Arduino and you have a pin number where a button is attached, for instance. So you need some identification of this pin. And it's possible that sometime in the future you rewire your Arduino. So you attach the button to a different pin and you don't want to rewrite all the places where the pin number is in your code. You just want to adjust one piece of the code, one place in the code and recompile it smoothly. So that's another reason why we are using a constant or constant expression. In this case using constants and constant expressions, there is one thing that's important. Sometimes you need to do enumerations. By by enumerations I mean you have a special type which isn't an integer, which isn't a string, which isn't anything. You just need to enumerate some values, enumerate states. You have a button and it might be released, pressed down or or being held for some time. So it might have us 3 states from your application point of view, you have a light in this room. The lights in this room might be in state they are turning on, they are being dimmed from zero to to some maximum illumination. They are being turned off or they are on or they are off or they may be also in some maintenance mode where they are flashing or something. So they are like a special cases, 5 cases, for instance, how the state of the light in this room can be described. Yeah, I'm making things up. I'm not sure if I can make them blink, but just imagine and just assigning arbitrary numbers like let's say 0 is turned off, 1 is turned on, 2 is they are being turned on continuously, 3 is they are being dimmed down or something. Who would remember these constants? Who would remember these values? Yeah, you can use constants to just mark all these value, all these special values, and then use an integer to represent the state. But it's a bit clumsy. So exactly for that reason, we have a special type called enum. Actually in C++ in Alt C, you just use enum. But in modern C++ we use class enum. OK, so just remember the class Anum. It's, it's better to start with the better with the C++ way right away. And here you can specify identifiers for the individual states. So actually we don't know how they will be represented in code. Well, we know, but it's not important how they will be represented in code in memory. The important thing that is that I will refer to them in my code using these identifiers. So in this case it's a stopwatch, I think no, it's some something that can be running or waiting or or whatever. So it's some some machine that can be in the one of these three states. And this state can be represented by one of these constants. So I can use this constant and assign to it or I can compare this state to one of these constants. Internally, enums are translated into integers. So in the end, waiting would be something like 0 running will be probably one stop read probably 2. But that's that's not none of your business. That's not your concern. You are using only these constants so everybody can read it much more clearly. Because if you comparing whether the state is stopped, then you know that the machine you're working on is stopped, not that it's in the state 2 What what the hell, whatever that is. So these are special traits in in C++. Another topic that needs to be covered right away is the preprocessor. The preprocessor is a special tool in the compiler. It's like a first stage of the compiler. The preprocessor arranges and puts together the source code in its native text form before it gets compiled. So it's like a stager, it's like a, it's like a thing that arranges stuff together before the compiler can take a look at the code as a whole. So what it does 11 important thing that it does is it processes the include directives. You've probably already seen the include. If you where in the labs you must have seen the include because you basically cannot write anything in C without include. Include is something like an import in Python. So you know that you need to import some libraries. In this case you are not important libraries, you are including headers there. There is some difference. The include actually works as a copy paste tool. So basically there is a path after the include path either to your file or to some file header file which is somewhere in the system libraries. And this file is really copy pasted where the include is. So you really take this file and replace this. Sorry not you. The preprocessor will take this line and replace it with the contents of this file, with all the benefits and all the troubles that comes along with that. OK, so it's not the same as import in Python, because import in Python works on a slightly different level, but from the perspective of what you need to do in your regular code, it it works the same way. Another thing you can do is define macros. The macro is a again some identifier. In this case I chose a quite short identifier, only N and this is just a basic text replacement. So every N in the source code will be replaced with the macro value 1000 in this case. OK, so if I if the preprocessor encounters N anywhere in the code, it will be replaced with 1000. So this looks like another way how to declare constants, right? You can declare 1000 instead of constant Expo, which I instead of this which I which I presented in the previous slide. However, do not do do this. Use construction expert instead. Because this step is done by preprocessor, so you're basically replacing the N with whatever the value of macro is before the compiler takes glimpse at your code. This may be useful in some very Special Situations, but in regular situations you don't want to do that. You really want to make sure that the compiler will take a look at the value N and for instance, perform type checking. Because as you can see on the previous slide, a constant expert is bound with an exact type like a variable. So what what the compiler does on content expert values is it performs type checking. If you leave that to macro preprocessor using this define, then you get rid of that. Sometimes it might be good if you're doing something very special or something in very low C, but normally for the regular code you don't want to do that. So use cons xper instead of instead of this. And finally, and this is for advanced users only, you can also make a conditional code. So you can make an if def block which kind of a covers part of code. And this code will be removed if this macro isn't defined. So if you if you defined a low debug macro, it might be empty. But if you define it, then this code will hold, it will remain where it is, just the the preprocessor will just remove all the things starting with hash. OK, but if this macro isn't there, everything between this if def and and if will be removed. So it's another way how to let's say compose your code on a high level. This might be useful for debugging. For instance, if you have some debugging code in debugging print outs in your code, this is the way how you can conditionalize them. So this is the way how you can remove them for the production version of your code. Actually, there are better ways how to do this in C++ is this is just to give you a glimpse. It might be useful if you're if you're advanced users and you want to debug Arduino. OK, another topic is the application entry point. I already mentioned that in the Hello world example. So you and you already need to know that because you already written some C code. So the code which which is executed the first the main code of the application is placed in the function named main. The important thing is that we have no top level statement. So every code in C++ must be placed in a in a function or in a method or something. But it cannot be as a top level statement. At the top level we are only declaring the functions, the structures, global variables and stuff like that. Important things you need to know right away about main is it has a a return value which is an integer. And this integer isn't just an arbitrary integer. This integer will be actually assigned as the exit code of your process. So usually if everything works fine, you should return 0 because zero is in all operating systems I know viewed as a success exit code. Nothing's wrong. errors, something like that. If you return a non 0 exit code, it's considered a failure. So something happens in your application and the application couldn't quit properly, couldn't be terminated, they didn't. They didn't finish its computation or something. Usually this is This is very useful if you're designing some command line tools, because command line tools somehow communicate via these exit codes. Normal operating systems has only one byte, like Linux has only one byte for an exit code. So exit code. Although this is an integer, the exit code must fit the range from zero to 255, otherwise it's it doesn't work. So just pace yourself if you want to use many exit codes. It doesn't give you much information to be smuggled out of your application. If you're if you're thinking this way is is really just an just an indicator whether the application submitted successfully. Or you can have some list of errors, error codes in your documentation if you wish. And second, second thing is the input of the application speaking in the command line terms. So basically, if you're designing a command line tool, you usually want it to respond to additional options, parameters, arguments that are transported that are provided via command line. I think you already have Linux, right? So in Linux you already has at least a glimpse of the command line and you need to use some command line tools. So this is how this works. You need to pass down to these tools some options or parameters, and you can receive these parameters via these two input arguments of the main function. This is the number of arguments passed from the command line passed from the prompt. And this is an array of strings. Yeah, this is character* which means this is a string which holds a list array of all the arguments given to C strings. Beware, the first argument is always the path to the executable file path to your program how it was executed. OK, so this is the most important thing in in see about the main application entry point. And now let me start with a slightly more complex topic and that will be pointers. Pointers are very important and they are very special because you won't encounter pointers in other languages in in C# or in Java, pointers are hidden from you. You have referential types in C#. You probably notice that because you also have some C# already, but and there are some pointers beneath these referential types, but you cannot create them manually, you cannot directly access them. You you cannot handle them in a raw way. So only the C and C++, at least from the mainstream languages, will give you that opportunity and the opportunity to fail horribly. Because if you do something slightly wrong with pointers, then you usually do something very bad with your application. Pointer is basically a number. Pointer is an address. It's a number that stores an address. However, it's treated very specially in their application because it's like a really a direction, an arrow that that points to something. What's important is, yeah, technically we could store the addresses as regular integers, right? So technically we wouldn't need pointers. We just say, OK, this integer is, is an address and I will use it in an address manner. Yeah, this is how it works in assembly language. But in C language we want better control over the pointers. So the most important thing is if you just allocate int or on integer type for a pointer, it might not work because the size of the pointer depends on what architecture you are. If you are on a 32 bit architecture, you will get 32 bit pointers. If you are on a 64 bit architecture, you get 64 bit pointers. Then again, integer doesn't have to follow the same logic. Integer on a 64 bit architecture X86 is still 32 bits wide. So basically you have to be extra careful and you need to put extra effort to recognize how wide should be the number where you're placing the address. With pointers you don't have to bother, the compiler knows how wide should be the pointer, so we do automatically allocate the right amount of bytes for each pointer. So this is the first advantage. And the second advantage is a pointer has a type, so we always know what is the data to which the pointer points. Yeah, that's right. Sometimes we need to sequence the words correctly. Basically, I cannot create something like AI can be a pointer to a student. OK, so I can point at any of you. And the benefit is that if I know that I am appointed to a student, then I always need to be pointing to a student or I can be pointing to null saying I'm not currently pointing at anyone right now. And the benefit is that let's say a janitor comes comes in or, or a homeless guy from outside just came in. So I can't point at him because he's not a student or the the janitor at the reception, she's she's not a student. So I, the C++ wouldn't permit me to just take just point at her. And the benefit is that if I'm pointing to a student and I want, I want to pose a question like, yeah, I, I don't have any tough mathematical question at mine right away, but we'll just assume I'm, I'm asking some very tough mathematical question that, that it might be worthy asking this question, some of you, but it wouldn't probably wouldn't be worth it asking this question a homeless guy or, or the receptionist. OK, so this is the benefit I get that I know what I'm what I'm pointing at. And the CC plus plus language wouldn't allow me to point anywhere else. So it wouldn't allow me to take a pointer to a bad type. Actually this is not completely true, because I have casts, I can cast pointers to different pointers. So yeah, there are tricks how to manipulate this mechanism. But when I'm not using these tricky things, then the C++ will like protect me at least a bit from taking a pointer to a bad, bad type. OK, how this works? Yeah, I just assume I have a variable, integer variable somewhere in the memory, probably a local variable or global variable. It doesn't really matter, it sits somewhere in the memory. It takes about 32 bits, doesn't really matter it it sits somewhere in the memory. And then I want to take a pointer to this variable. So first of all, syntax, the pointer is declared using an* in front of the identifier. So this end is the pointer type, is the data type to which the pointer points. This is a regular variable identifier. And this* indicates it's a pointer. OK, And this & is a operator. Note it's a unary operator, not binary. It's not bitwise AND. It's a unary operator, and if you use it to before in front of a variable, then it takes the address of the variable. So instead of taking the value of V, it takes the address of VI. Know that V sits somewhere around the address 1234 in memory. This is the index of the byte where V starts in the memory. Just imagine the memory as a linear array. So this is the offset of V in the array in this array. So basically I'm storing value 1234 inside this PV variable. Pretty obvious right? I hope And just wanted to lay down slowly so everybody can understand and everybody can catch up. And the most important thing I can do with a pointer is that I can dereference it, which means I can access the value via its address OK. This asterisks in front of the pointer value expression if I don't use. If I use PV without the* I'm using the pointer itself. I'm using the address itself. If I place*, it means, OK, take one step further, interpret the address as an address and go to that address and give me or in this case writes to the value which is there. You can use it both on the left side and the right side, so you can use it for reading and writing. So in this case, I am, I am all writing the value of V because I'm writing to the address 1234 and I'm putting a four in there. OK, everybody's clear on that. I'm sorry. I'm taking this one step at a time very slowly because I really want to make sure that everybody gets every detail. No problems with that. OK, so few more things. Pointers are important for us in many ways. Some of them you haven't begin to realize it, or maybe if you work with C or C++ in in in the past you you have. But this is important that the. Arrays are basically pointers. Arrays are pointers in disguise. If you have an array, it is internally represented as a pointer to the first value. If you pass an array into a function, you are not copying the array as a whole. Well, you you can, but you need to specify it differently. But if you just pass it down, you're usually passing down the pointer to the beginning of the array. And that's very important, very important thing. So just imagine that you have this and this arrays, this, these two are almost equivalent. Yeah, actually there are some minor differences if you're accessing this variable and this variable in some manner. There might be there might be differences if you, for instance, take the size of these two variables, there will be different. I'll get to that shortly. But from the perspective of reading or accessing the elements, they are both the same. Yeah, in this case, I'm storing the whole array in here. In this case, I'm taking a pointer to an array which is allocated somewhere globally, but that's not that important. Same thing goes for four strings, right? So for instance if I create something like this, it will be laid down in memory as follows. So this is XKCD acronym. Actually it's not acronym, it's just you can you can Google it up if you don't know what it is. But this is a four letter word and this 4 letter word is declared as a string. So it has A5 bytes in memory because it needs the new termination at the end. So somewhere in memory there will be 5 bytes occupying these 5 characters and string over here will basically hold the pointer to the big to the 1st letter to the first character of this string. OK so this is what I what I was trying to told you from the beginning, but now with the pointers you have really taking the grasp how this works and that reveals the nakedness of of strings and also of arrays. If you need to know how many characters are there you need to somehow pass it along. In case of strings we are using the end the termination character to find out where the string ends in the memory. As you find out in the labs, if you need to pass down an array into a function, you also need to pass down the size of the array as an associate parameter. So you cannot just pass the the array itself because you wouldn't know how large the array itself is. The pointers in C are equipped with something which is called a pointer arithmetics. It allows you to compute shifts. You can compute another pointer from 1 pointer by adding values to it. So it's kind of strength because basically in most languages this is not allowed. You can take an address of existing object, you can create an object and then you get the reference to that object. Yeah, you can. You can have a noun, so you can have some special pointer that points to where, but you cannot just shift the pointer around in the memory. For instance, in C#, you cannot even, at least not easily, take a glimpse on what the reference actually is. You cannot get to the numbers. In C it's. It's much more easier. But what C gives you in addition is that you can take a pointer, add a value to it, and you get another pointer. So you can create arbitrary pointers in your memory regardless whether this memory was allocated or not. Which is very handy if you know what you're doing, and very dangerous if you make a mistake, because you can easily create a pointer that points to a memory which hasn't been allocated, for instance. Right how this works, I will start from the from the middle this syntax which is accessing an element of an array. Actually it's a string, but that's not important because string is an array of characters. So accessing this character is actually equivalent with adding I to the pointer itself and then dereferencing it, then accessing its value. OK, so these two things are equivalent. It's your C++, I'm just taking a second so that it this message can sync In Sync in. So if you're accessing an element of an array, you are basically taking the pointer, adding a value to it, and then dereferencing it. This works fine because, well, this must work fine in any case because the pointer points to a character and character takes 1 byte in the memory. So if we advance a pointer by I bytes, then you will arrive to the desired character, right? Everybody sees that. But this works if you have a point, an array of integers as well. So if you have a normal array. Like this it will work as well. So if you write something like array +2, it will advance the pointer not by two bytes in the memory, but by two integers in the memory. That's the trick embedded in here and how we can do that because we know the type of the pointer. So thanks to that we can do pointer arithmetics without too many errors. Yeah, it's still very error prone, but at least we don't have to bother with finding out how what's the size of the base type of this array it's embedded inside. So this is advancing the pointer by two integers forward. And also This is why it's very important that an array is allocated as a continuous block in the memory, because if it wasn't continuous, this magic wouldn't work, right? You couldn't. You couldn't just index using this point to arithmetics, because it will break down. This works only because it's an compact block in the memory and you can access each element of the of that block just by computing its address using a simple multiplication and addition. So I'm just telling you this. By the way, this is one of the greatest mistakes I we usually make in this class. We introduce this syntax and then suddenly all the students are starting to use this syntax for accessing array elements. Please don't. This is just an example to make you understand how the pointer arithmetics work, that the pointer that the array is basically just a pointer to the beginning of the array and how the elements are accessed. But always use this syntax instead of this syntax. This is much more longer, less readable, it doesn't work in other other languages and it's it works only in low level C If you just want to switch an array for something more convenient like a vector, which is a standard container, then suddenly our code would broke break down. So it's better to use always the bracket syntax, not the point of the reference syntax. On the other hand, sometimes you can use point of the reference syntax, usually in this manner. This is like a piece of code that's that you can see many, many times if you just dig deep enough into some old C code or kernel functions or stuff like that. If you want to iterate over a string, one way how to do it is using a while loop. Because in the end, yeah, you can, you can rewrite it in a for loop like this one. But in the end, if you don't really need the index, if you really need the the pointer to the actual character, then this will access the actual character and this will advance to the next character. So you can iterate over the over the whole string, processing each character for instance using this while loop. OK, besides pointers, well, pointers are necessary if you're writing in plain C As you notice that I'm sometimes saying CC plus plus, sometimes I'm saying both. What we are trying to teach you here is C++, but we are focusing on the subset which basically almost covers C This doesn't. This is AC plus plus extension C++ feature. And these are references. References are also pointers, but they are slightly different. The reference pointer is not reassignable. Once you create a reference, it cannot point anywhere else. That creates a small conundrum because it's like, it's like, what? Why would we need that pointer? One of the greatest benefits of a pointer is that I can point to one student and later I can point to another student and later to another student. Sorry if if I'm bothering you with pointing my finger on you, I'm I'm not pointing any fingers right now. OK, in a literal sense. So basically if you have a non some, some mix up with the animation, sorry about that. So if you don't need, if you don't allow your pointer to be erased sign. If you cannot point to another example of the data type, you lose something. On the other hand, you get something. The reference is always assigned. So first thing is that you cannot get a null reference again. You can create it if you really really want to, but it's quite difficult. You need some castings and some some tricks to do to do that, and it's considered a bad thing. So normally a reference is always valid, so you know there is something at the end of that pointer, something valid this pointer points to. And 2nd, it stand to reason that there are situations that you really don't want to change the pointer. For instance, if you're using the pointer to pass something down to a function, I will get to that in short order. So if you need a fixed pointer that cannot be altered so it cannot be for instance altered incidentally or accidentally, then reference is your choice. Again I will use the same example. So we will have AV variable which sits somewhere in the memory. We already met this one so we are already acquainted with it. But this time I will take a reference to it. So instead of using esterisk which denotes pointer I am using & to declare this PV is a reference. Now thinking about it I may I may be I may change this to RV because PV was pointer to V so RV would be like a reference to V So sorry about that but not that important right now. Just to remind you when we are using pointers there were there was* over here and there was & over here. So we just shift the & here and there is only the V How the reference would know that we are that we want to take the address of V? Well, the C++ knows because when you're assigning something to into a reference, it only can be an address. So basically if we can only assign addresses here, there is no point in copying the value of V we can only take the address of V So it we can save one one character from our code at least. And second thing which is saved here is that since the value of the reference cannot be changed, we can strip the & or* or whatever when we are accessing the value of the PV. So we are reading or assigning something via reference. We don't have to dereference it because it's always automatically dereference. We cannot access the address itself easily and it doesn't make sense. We cannot reassign the address. So it doesn't make sense to assign another address here. So the only assignment valid here would be the assignment that rewrites the target memory, right? So basically we can spare another character here. So yeah, in the end, the four is over it. The 8 was over it with the four in the V variable. So this is the same example as with pointers. We just save save some some writing. When in doubt in C++ whether to use pointer or reference, and the reference will do, then use a reference. Yeah, it's like a. Take it as a rule of a thumb if you'd like. So if you don't know whether to use pointers or references, then use references. If you cannot use reference for some reason and you really cannot make it work with reference, then you probably need the pointer practice. Would you ever need a reference? I'm not trying why you need a reference. I will give you a very good example in short order when I start talking about functions that that's the perfect example for reference. So bear with me, it will come soon. So this is the example. Actually, this is the prelude for the example I was talking about. The pointers and references are most useful when you try to pass something down into a function. One of the important things you probably learned about functions is that if you have a function and you're passing a parameter, it's always passed by value. It means a copy of the parameter is passed down to the function. You can modify it, but the original value wasn't modified. So if you have a variable which is passed as an argument of the function, yeah, it can be modified inside the function, but only the local copy is modified, not the original variable. Sometimes you need to, Sometimes you need to pass down a variable, and you really want the function to modify that variable. Yeah, one way how to do this is that the new value of that variable can be passed down from the function, right? So I just assume I have a function fool which takes one integer and I want to modify the value of this integer I'm passing down. So one way how to do deal with this is that the Foo returns the new value of the integer and then you need to use it in this special manner, something like. Let me use a different thing. A equals Foo, so you provide the old value, it's copied inside. New value is computed and returned as a value which is assigned to a. Sometimes this might be a good idea to do that, so the caller can choose whether the original value will be overwritten or whether it will be updated or whether you want to store the new value into a different variable. So sometimes this is a good idea how to deal with modifications. And furthermore, if you do it like this, then Foo might be a pure function. And I mentioned or maybe your teachers mentioned that pure functions are always better than normal functions because they have no side effects. They can be optimized better, they can be called in parallel, etcetera. However, there are times when you need to modify the argument that's that is being passed to the function. And for that we have pointers. So give me an example. This is a rotate function which gets an input structure and output structure. So basically we want to copy the input structure into output structure which is a point in 2D and we want to rotate this point 90° around the origin. So it's just a very simple operation. You just swept the X&Y and one of them is gets negated and that's that's the rotation by 90°. It's very simple. If you don't believe me, then just use the linear algebra you already have and you you can do it. And if you just fill in the 90° in all the sines and cosines in this multiplication matrix, you will get, you will get to this formula. The syntax which is important to us is yeah, here we are accessing the input structure and we already know that the input structures are accessed using the dot notation. So here we are accessing the Y&X values fields of of the input structure. That's fine. The input structure has been copied inside, so the in is a copy of whatever point we get as the input. However, we need to somehow pass out the new new point, so the output point is passed down as a pointer. This pointer needs to be the reference, so I'm using this notation. It's a dash and a greater than which visually forms an arrow. So it's like a dereference of a pointer to a field. And basically this syntax or this syntax is a shorthand for writing a pointer D reference and then applying a dot notation to access field to it. So it's it's we're still accessing a field of an of a structure, but since we have a pointer to the structure, that pointer needs to be dereference first so we can access the field right? Like we have the shorthands. It is, it is forecast or it's shorter. Some people decided it's it's like, yeah, first it's shorter and but some people decided it's like a more readable. It's because it's look like an arrow. It's it's like a dash and less than. So it's it's like a arrow to to emphasize that you are using a pointer to point to something. I don't know the etymology of this idiom, so sorry I don't have the insight and knowledge about why people decided. However, it it sticks in some languages. For instance, in Python, sorry in in PHP we we use this to access fields that that's another story because in PHP the dot was used as an operator for concatenating strings and then later when they add structure, added structures and classes they they realized, oops, we used. Dot for something else. So we really need another another token to to use to be used to access fields. So they use this from C to access field, but that's a different story. OK, so this is how we how we deal with that. What's the trouble here? Well, one trouble is that we need to explicitly, well, maybe not the trouble. One fact is that we need to explicitly distinguish accessing a simple structure and accessing a structure via pointer. On one hand, it might be good because you are explicitly stating you are accessing something via pointer. Everybody sees that it's perfectly readable. On the other hand, it's a bit tedious because every access must be carefully considered. So whether you're using a pointer or not, it's up to you. Second trouble is that some someone may incidentally slip in a null pointer. A0 pointer? That's valid. Pointer that's pointer that points to nothing. I already mentioned that in a in a sideways, but this is like a trap, because if somebody just give gives us the null pointer, the 0 pointer which doesn't point to anything. And the code gets in here because and it will because there are no conditions, nothing else. So here it will blew up in our face because the processor will try to dereference a null pointer which wouldn't work and the only thing that the processor could do is a I'm not executing this code just take it away and the the application will fail in something which is called segmentation fault. So if you ever seen the segmentation fault error, this is one way how to create it dereferencing a null pointer. This is one reason why the references are better. So we are getting to that. If we use a reference instead of a pointer, then first of all the compiler will enforce that here will be something from which we'll take the address, so something valid. We cannot create easily a new reference here, so this reference will be valid. We we can easily access it without checking. That's one benefit we get and the second benefit we get. We won't accidentally change this pointer. We really don't want to. We want that this pointer, actually this reference, sorry, always refers to the variable the caller gave us when this function was called. We we cannot change it by accident, the reference won't allow it. So This is why in this place references are better than pointers and that's one of the use cases which where the references are better than pointers. Second, very tiny benefit or maybe not benefit it's depend on a point of view, is that we use the same notation, only the dot notation to access both the regular structure and the reference structure. Again for the same reasons, there is no point in in distinguishing because we cannot possibly access the pointer itself which is beneath the reference. So the same syntax applies for the regular straight data structure and the reference data structure. Tiny, tiny advantage is when you suddenly when you pass down something as a value and later you decide you need to modify the the behavior of the function so it's get modified inside. You can just add the & here and everything changes. You don't have to rewrite the code because you use the same notation for regular structures and reference structures in the code. That's one tiny benefit. Also, it may be a pitfall because if you do it accidentally, then yeah, it might be also a pitfall. OK, So what you should learn from this if you didn't get all the details on the pointers and references and how they work. Just remember if you want to use a mutable parameter, something that is changed inside the function, you just use the reference. You just prefix it with & and it it will work fine. It will work as as easily as as as in any other language, like an out keyword in in C# language for instance. OK, I've spoken I've spoken about sizes of things for in a few places in this lecture. So let me give you an overview of a very important operator for low level programming. And this operator is called size of. It's very useful because it can take a size of things at compile time. So this is not like a regular operator which computes something at runtime and give you the number when you actually don't need it. It gives you the number, it gives the, it gives the number to the compiler. So the result of the size of function is basically treated as a constant. So it can be used to allocate arrays, it can be used to initialize constant expressions in, it can be made to make a compile time decisions when some some code is compiled in One Direction or in the other direction. Quite important in the size of operator you can specify either a type or a variable. So if you place a type there, it will give you how many bytes in memory this type normally takes. So this on most architectures will return 4. Because on most most architectures in integer has four bytes. There might be architectures with different numbers. For instance, if you try this on Arduino, you will get 2 because on Arduino integer regular integer has only two bytes. That's one of the pitfalls you should be aware straight away when you're dealing with Arduinos because yeah, the architecture is not 32 bit wide so they just use 16 bit int. If you have a data structure, meaning C structure, you can also use it here to find out how many bytes the whole structure will take. Beware that thanks to the padding, this may not be equal to the sum of the size of of each individual field in the structure, right? This may be larger because they may there might might be some internal padding. By the way, if you're not certain how the padding works, it's a good idea to just, I don't know, run replit or some other environment. Or if you have your own CC plus plus environment and just try to taking size of of a few data structures of of few C structures and try to shuffle the the fields in there so you can see how the padding works for yourself. It also works on variables, so if you just take a size of a variable it works fine. So in this case if you take a size of U variable, the compiler knows that U is actually an array of four integers. So it will give you 4 times size of an integer which will be 16 on most architectures, 8 on Arduino. OK, but and now we are getting to the difference between arrays and pointers. If you just happen to take an. Sorry this is still an array because we are not specifying the size of the array but the compiler infers it from the initializer. The initializer will take 5 + 1. Don't forget the the trailing zero 5 + 1 characters. So size of S will be 5 + 1 size of character. Size of character is always one on all architectures. It's like a rule in C++. So this will be 6 always. However, the tricky part is if you arbitrarily intermix pointers and arrays, sometimes it doesn't work as you expected. For instance, if I do the same thing here, the the only difference is that I didn't declare this as an array, but I just declared as a as a pointer. By the way, important fact, also a pitfall. This construction care refers to the character, not to the pointer. Which means I can still change where the pointer points, but I cannot change the characters to which they point, I can only read them. So this is a read only pointer, but I can still move the pointer, I just cannot modify the data to which the pointer points. OK, this is a common misconception. If you have a construction character pointer, the construction refers only to the target type, not to the* By the way, you can have cons character cons pointer. You can have but you need to specify 2 cons in there so both the the pointer and the character are constant. You can also have a non cons non cons character constant pointer, but and I wouldn't know where to use that. But back to the example I'm trying to back to the code I'm trying to explain. So this is quite different because yeah, it will still create a string somewhere in memory, somewhere in global memory perhaps. And yeah, this will still take 6 characters, like 5 characters plus the trailing 0. But this data type is different than this. This is only a pointer. So if you take trying to take size of this variable, it will give you the size of the pointer. So it will be equivalent with the size of a character pointer, which on 64 bit architectures might be something like 8 because it's 8 byte wide. This pointer on 32 bit architecture, it will be probably 4, but it wouldn't give you the number of letters in here because it doesn't know it's just a pointer to the beginning. Here it really stores all the characters. The S variable represents the place in the memory where all the six bytes, all the six characters are stored in the memory. So that's the difference. This is just a pointer to the beginning. By the way, if you dereference it, you won't, you still won't get the right answer because it will give you the size of character. That's very unuseful information. It's it's always one, so beware this pitfall. This is also why you cannot take the size of a constant array inside a function if you just pass it down to the function. This is the pitfall you encountered in labs, right? At least one guy is nodding over there. I I just hope he's nodding and not just chilling out or listening to music. So beware this pitfall because it can bite you. By the way, if you really want to calculate how many characters are there in the string, there are functions for that. For instance, there is a standard function called sterlen string length which calculates how many bytes are there. It just traverses all the bytes until it finds a zero in the end and and gives you the number of characters it encounters. OK, a few words about C++ classes. In the end, as I told you, this course focuses mainly on the C part of the C++ language. So we are kind of focusing the subset. We are not trying to give you the bad, bad impressions. Because in regular C, well, I wouldn't say no one programs in regular CI know a guy or two, but it's rare if, unless you're doing something very low level like a programming a washing machine or programming a Linux kernel, you are not writing in C and you don't want to write in C, well, unless you're Martin Marish or someone. So basically we are not trying to give you bad impressions, but some, some pieces of this puzzle needs to be hidden till the 2nd year because we don't have time for everything. On the other hand, classes are very useful and you might want to use them in your lab assignments. So I will give you a like a quick tutorial to classes, just the stuff you need. There are way, way many more information I'm not telling you right now. OK, so classes are actually declared in the same way as structures, just you are you just using the keyword class instead of the keyword struct. And technically in C++ structures and classes are actually interchangeable. They have too much in common. The only difference is in the visibility of the field. But you can still use structures instead of classes. Just don't. If you really want to use classes in the way that you intermix your data fields with your code, that's why we're doing classes. Then just use class, don't use structs. So the idea is that it's not not a good idea. Sorry, bad phrasing. The notion is it might not be a good idea to separate data from code when you're doing structures. You have data nicely bundled into a structure nicely packed, and then the code is somewhat separate. Let me just get back to the to this example. So yeah, I have this nice structure that represents a point in 2D and then somewhere else completely else, I have this function that somehow takes it and modifies it or produce another point or something. Not very useful. Well, the code itself is useful, but it's not very useful to get it separated, because if you get it separated, it's easy to lost track what's where. So it's always good to place the code and the data together or as as at least as close as possible. And that's what classes do because they intermit mix code and data structures, data fields. In this case. I have A1 integer in this class and I have some methods. Method is a function which is embedded in the class. It has the same syntax you you just write it in the same manner you are writing functions. So it has the return type identifier arguments, everything is the same. The difference is that the method can directly access the elements, the fields of this data structure of this class. So I can access the sum, which is some local data field from this function from this method actually. OK, so that that's the difference. I don't really understand what the third line they're doing. C I'm I'm able to getting into you're always ahead. I I like it because at least somebody's paying attention. Good for you. But please just give me a minute. I I will get to it in short order. OK, so these two are regular, regular methods. By the way, this constant says that this value, this function would not modify the contents of the class of the object of this class. OK, so this is just a detail for advanced people. And now finally I was I skipped this line. This special line is like a special function which is called a constructor. It's a one time function which is called only when the object of this class is instantiated. You already know what an object is right from from programming classes. You already make some objects from classes on in C# classes. Otherwise you couldn't code anything in C#. So I believe you already did that. So yeah, when you're creating an object from this class, this function, this constructor is called just once on the new instance, and its business is to initialise the fields for that. Yeah, you can see the constructor may have additional arguments, some don't. This is like a default constructor because it doesn't have any arguments. So it's it's easy because you can create an object without passing anything to the constructor. And this weird syntax is just before the body. Yeah, I can write in the body. I can write sum equals 0 and it will work. It will initialize the sum, the sum field of this newly created object to 0. That's what I need to do, because at the beginning I haven't summed in this counter anything yet. So it's a good idea to put zero as an initial value, otherwise there might be something else. Well, actually not in this case, but I I really need to initialize the values so I'm sure what's in there. And this sum is an initializer of. This is also a constructor. It's like you're calling a constructor on the integer. Yeah, I know it's hard to accept that you can call constructors on integers, and I'm not going into the details, let's leave it for the second, second year. But this is how you initialize all the fields using this double, using this column. And then there's a list of initializers which initialize internal fields. This is like a more modern and more practical way how to do do that instead of writing sum equals 0 into the body of the constructor. By the way, there is also AD structure, which is which is written as a tilt as a wave and and the name of the class. But again, this is something we won't need in this class. So I will leave it to the to the second second term. Why are we doing classes? Well, there are two one important reason and that's it's it's called encapsulation. Sorry, my lips are getting stiff. It's called encapsulation. You may notice that I've used some very awkward keywords like public and private over here and they denote which parts of the structure are visible from outside world. So let's just say I create an instance of this structure of this class. Sorry, the easiest way how to do this would be to write this class as a type and then identifier. And since it doesn't require any additional parameters because the constructor is empty, that's it. I just declare it as a variable and it will create. It will be created on the stack. I don't have to allocate it dynamically using new. In C# you need to write something like equals new and then there is also again the name of the class, right? In C you don't. This is how we allocate the class on the stack, and this is usually how you want to do that. So I will create an instance of C and the difference is if I want to access the add method here, it's fine. I can write inst dot add and just call whatever with call it with whatever parameters I'd like. I can, however the sum is private, which means if I try to write inst dot sum, which would be a normal way how to access this field from outside, it will fail the the compiler won't compile because it would say hey, you are trying to access the internal, the private property of this class. You're not allowed to do that and that's what's called encapsulation. Some parts of the class, usually the data parts, usually all the data structures are the data fields are private and usually all or most of the methods are public. So when anyone wants to access anything in this class, it is using only the allowed methods and cannot access the private data. Why is that important? It is very important because no one can accidentally slip in and override this value. Not accidentally, not because it will be a malicious programmer who wants to ruin my code. It will prevent errors from from accessing the bad data. Only the interface. We call it the interface that the methods that are public know how to access the internal data and allow you to. To do whatever this class is designed to do without directly accessing its underlying data. One of the reason why is this important is that you need to program your. You need to design your code against a specific interface. So you need to use these functions and these are like a contracts. You you are giving some assurances that these methods will be there for you no matter how the class is implemented internally. You shouldn't know how this method is implemented internally in order to use it. And if somebody decides that it's time to replace this class with another class which would be implemented differently, for instance more efficiently, or do something slightly else just on the same interface, it's fine. That's that's why we are doing this. If you didn't take everything, don't worry. This is a concept which is which, which will be repeated in many classes. This is like a very important concept and we will build upon that later. And actually in the fifth, sorry, in the yeah, in the 5th labs, you will be introduced to the fifth unforgivable curse. And it's about encapsulation. So you will be encouraged or slightly enforced to at least slightly embrace this concept. So separate your concerns, separate your code into classes and design appropriate interface for these classes. But don't worry about it. You will be guided through this process throughout this semester. OK, so this will be this was a very brief introduction into classes. Yeah, I've, I've leave a ton of things out of this because there are so many things in C++. But let me leave that to the second, to the second semester, OK, One thing which is quite important, right away you were introduced into the courses, right? Your lab teachers explain things and you already have been explained the first course. So, yeah, why we are calling this curse is because when we call that subtle suggestions, nobody would pay attention. So that's why we choose this very harsh label for that. But basically these are rules how to design A better code. These rules will be given for to you one by one in the labs, but all the rules are already here. And I suggest strongly that you just run through them. There are motivation explanations, there are examples, there are some additional information that might be interesting to you. So it's a very good idea just to read this stuff and understand this stuff even before you get to to to it in the classes because you know it will really take some time to sing in sink in this information. So it's better that you know everything in the beginning, not if if it's passed to 1 lecture at a time. OK, so let me finish because we are nearing the end. If you still crave Python, just remember, yeah, C++ can or C can be pain in the ***. But in the end this is in what we need to code because otherwise there would be no Python, there will be no JavaScript, you know run times of these languages and compilers are written in C or C++. So this is the language we will which we will still need in the future. OK, time for a few questions. But before I get to questions I have a like a three reminders. First one, don't forget to your get your arduinos right. Remember from the next week you will require to have your Arduinos in your labs. So get to the library or buy them if you'd like, but get your arduinos. Second, I've noticed that only about 1/2 of you, well I'm not sure about about you because you are intermixed with the check group, but only about half of the students are enlisted on matter most. So if you haven't enlist in the right channels on matter most, please do because this is the only communication channel we are using. Don't send us e-mail. We won't send you emails. We will send every important piece of information on matter most. So it's a very important for you to be there. And finally, I, I'm very pleased that despite the fact that I'm trying to record these lessons, many people have come to the second, second lecture. So maybe there is no point in in emphasizing it as long as you keep coming to the lectures. I will try to record them. If I notice that most people stopped visiting the lectures, then I'm not going to lecture for an empty hall. So if I'm not lecturing, there will be no recording. So as long as you're coming, there will be recording. So just please keep coming to the to the lectures. Don't rely on the recordings. Furthermore, you may have noticed that I have some troubles at the beginning. Get it running. So it might happen that at some point it won't. It will fail. It's possible that the recordings won't be made in in a good quality, so just don't rely on them. They are just a bonus that nothing that should be should be taken too seriously. OK, we have a few more minutes for questions. 2 more minutes for questions. Are there any questions regarding C or C++ before we finish? Not today. OK, If you do have some technical issues with your home assignments, don't hesitate to ask your lab teachers or me if you, if you, if your lab teacher is available. So thank you for your attention and see you next week.