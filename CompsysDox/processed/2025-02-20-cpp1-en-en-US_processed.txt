So hello everyone, I trust we are all here for the Introduction to Computer Systems course. So before we get started with the course, let me just give you a few information about how this course will be conducted and for what will you receive the credit and how the exam will be organised. So first of all, the most important rule of all is that on this web page, there are all the information out on this web page. So please go there, read it. There are grading rules, rules, how you submit your solutions to record X rules, how you receive your credits. These materials you will see here the slides, materials for your labs, everything is there. So please visit the site and I will actually I will go there right away so that you can take a glimpse of this web page and I'll show you the most important part. So first of all, yeah, you can get them just a second so you can get the slides right away. And most importantly, you can find the grading rules there. So let me start with the grading rules. In this course, the credit for the labs and the exam are completely separate. And as you will see in in future, the lectures are somewhat detached from the labs. So this course is somewhat awkward in this way. Unfortunately, that's how it works, so we cannot do anything about it. It's like a political decision. So for the labs, you need a credit and the credit is granted for two things. You need to do home assignments and afterwards, at the end of the semester, you need to pass the lab test. So that's how you get the credit. There are 6 assignments. Basically, you get one assignment on each lab session, and you need to finish it within a week if you want the points and within four weeks if you want to pass the course. So we were the deadlines. The deadlines are in record X. You really need to meet them, and you need to gain at least 13 points from these assignments. So there's a point limit you need to pass. If you do the all the assignments, then you can go to the test at the end. The test will be conducted in the labs. So basically you will be locked down in for two hours in labs and you you just code something on Arduino. That's basically it. One thing you should know, you can use the code, you code during the semester, during the labs. So if you prepare yourself well, if you do good work on your home assignments, you can take the code from home assignments and reuse it during the test. That's by the way, a very good idea to do so. This is the labs. Again, please beware the deadlines and beware how the submission process works. I just give you a very quick, quick hint. You can get more details from your lab teachers, but just to give you the preview, I believe some of you probably already had the labs right this year. It's somewhat awkward that we have labs before the lecture in the week, so it's kind of strange. But for the submission, there is a like a very simple process. You can see it fit fit only one page. Basically you need to submit something into record X that passes the record X test 400%. We don't take glimpse at your solutions that are not meeting the test requirements. So you really need to pass the test in record X. For each solution you will need the acceptance flag. So the teacher needs to recognise that you have submitted on time the solution and you will receive this acceptance flags. If you don't have this acceptance flag then something's wrong and you should ask why you don't have the acceptance flag. So you need 6 acceptance flags from each solution one. And there are two deadlines for each assignment. So basically there is one deadline one week after the assignment is issued, and then there's another deadline three weeks afterwards. So four weeks after the assignment is issued, the first deadline you need to meet if you want the points. So if you want to receive any points from the assignment at all, you will have to meet the first deadline. So you have to submit something that passes record excess 100% before the 1st deadline. Afterwards, after the first deadline, your solutions will be reviewed so that your lab teachers will take a look at them and manually review them. If they're OK from the perspective of code quality and you will get to that in the labs, then you get the point, you get additional points for code quality. If not, you don't get the quality codes, but you can fix the assignments later to get the quality code points. But you need you need to do that before the 2nd deadline. And also if you miss the first deadline, you are no longer eligible for points for this particular assignment. But you can still get the acceptance like if you meet the second deadline. So basically each solution needs to be done at least within four weeks after it's issued. If you miss these deadlines, then you are dead. From the perspective of the course that that's like a hard rule, they are not that difficult. So you can meet these requirements easily and we issue these rules because the assignments are incremental. You need to finish one assignment to start another. Well, the first one is somewhat just get you started, but from the second on you will need to do them gradually. So it's a good idea to force you into making them gradually over the semester. So that's basically it. Let me switch to the exam portion. The details about the about tests you can read on the page, but basically the test is just that you called something in the labs that that's it. Regarding the exam, exam is completely separate. So you can achieve the credit, You can get the credit and go to the exam completely separately. You don't need to have the credit before you attend the exam. It's not not mandatory and the exam is basically a also a test. It's incidentally also in the labs, but you are, you are not going to code in the labs. It's a test like you just select from multi church questions, etcetera. And you receive some points that you can get up to 20 points. The grading table is over there. So you can, you can see right away how the points are distributed. You need at least 11 points out of 20 to pass the test. So that's the that's the bottom line. And basically you have regular 3 attempts. It's it's like a normal, normal exam. There is there are no surprises there. OK, so this is how this course will work. Are there immediately any questions regarding the grading process? No so far. I have repo that's open right now. I'm not seeing where it would be that I would find the whether or not I got the like the check mark You can you can see it at the at the submissions. If you see the submission, if I expect you haven't submitted anything yet, you already have. So the teachers will give you this acceptance check mark after they grade your, after they read your assignment. So they basically check it was submitted on time. And usually they perform a review. So basically when they do the review, they will also give you this assignment, this acceptance mark. OK, don't panic because the first reviews are due after the first deadline. So if you just submitted something that passes the test 100% you, you're OK for the first deadline. OK, that that that's true. Any more questions before we go on? So this is the grading process. Let me switch back to the slides. If you cannot attend the lectures or whatever, or you want to study on your own, there are some books listed over here that you can take a glimpse at. Basically, yeah, they are like more broader, they they cover more broader topics than what we are going to cover in cover here. But they are also a good point to start if you want to study further. And perhaps the most important communication rule for us is that we are using mattermost. It's a somewhat like a Discord or Slack, but it's our own private platform. So we don't have, we don't have to worry about GDPR. So basically you need to attend. Sorry, you need to attend. I really need more, more powerful pointer. So you need to attend this address. Actually the invitations link were sent to you via e-mail. I just hope you got the right right links because we kind of screw up at the beginning. So first you got the wrong links and in the second iteration we we send you the right links for this year. If you cannot find them, they are also insists. So this the the invitation link for matter most is attached in the note in the sys schedule labels. If you just go to the sys to the schedule, you can see there are some notes attached to the to this lecture. So basically go there and if you have any questions whatsoever, go check into this channel and ask questions there. Beware this, this channel is shared for Czech students and English students. So don't be unnerved that some people might post questions in Czech there. It's fine. Don't worry. Just pose your questions in English. That's OK. So just go there and ask anything you like. If you have any specific like a questions towards me and you don't want to share them with your classmates, then just write me a personal message, that's also fine. So this is how the course is conducted. The lectures are regularly weekly so we will meet here every Thursday. The labs are biweekly, so every every fortnight. So we have only six or seven labs during the semester. For the labs, there's one important piece of information I need to give you right away. For the labs, you will require this. It's earned Arduino device with attached shield. You can either buy one if you'd like, if you're a real fan, but assumingly you don't want to buy it, so you just can borrow it in the library. Only the library at Mahlastrana have these. So you really need to go there and ask for our do you know they will know if you just give them the code of the, the, the course, they will, they will know everything you need to know. You need to get so you get this box and you need to bring it to your labs because you will, you will code for this device. And again, don't forget the deadlines. Many students are confused for whatever reasons, so just go to record X and beware the deadlines because that's important. Deadlines are strict. OK just a few words about the outline of this of this course. This course is somewhat special in the in the sense that it's like an introduction to many other courses. We are trying to build upon what you already already learned in last semester from Mr. But so some some parts of this course will be just a repetition to and we try to elaborate on that. But we also try to introduce a few topics to other other lectures to other courses. First of all, we start with C++. Actually, this is not intended to be a language course. So we just take a 22 lectures about C++ to get you started so that you can code Arduino and so that you can understand the C++ examples from other parts of this course. That's basically it. But for the C++ language itself, there are two additional courses in the second year, the Basic C++ and Advanced C++. So for the language itself, we just defer many things to those two courses. After that there are some information we need to elaborate on on CPU architectures, how instructions work, etcetera. And hand to hand with that we talk about how memory works in in hardware. After that we will switch to programming languages. So basically we'll give give you like a brief introduction into compilers and how run runtime works and how applications are executed and the related technologies. Then we cover about four lectures with operating systems. Again, operating systems have their own course which is I think due in 3rd year. So we will touch only the basics. And finally we will spend 1 lecture on parallel programming because parallel programming is quite important nowadays, especially considering we have mostly parallel hardware. So we will give you the basics on that. So this is how this course will will go again. Please note that the course like the lectures and the labs are completely separate. We also give you some special dispensations like that. If you happen to like pass the exam and you fail in the labs, then we will just you don't have to retake the exam next year. We just rewrite the the your marks from this year to the next year. If you if you pass the test, if you pass the exam completely, and vice versa, if you get the labs, if you pass the credit and you don't pass, don't make the, if you don't attend or you don't pass the exam, then we just acknowledge your credit next year and you don't have to retake the labs, OK? Because these two are basically two different courses somewhat glued together. Are there any questions regarding this course before we get started with C? OK, let's dive in. Let's start with C Oh, sorry. So C++ language is a language that's not that different from Python in many ways. So I try to relate to Python because I believe everybody, everybody here already took at least one semester in Python. So that's like our common ground. And like Python, this language is procedural, imperative structured. So it's not that different. You have the same structures like if for loops, etcetera. You can create functions, you can decompose your code in the same way. However, there are some important differences. The most important difference is that the C is statically typed. I will elaborate on that in a short while, but just to give you the first clue. Now, static typing means that every variable, every parameter, every function argument, every return value has to have explicit type. So when you're declaring variables or parameters, you are always attaching the type definition to that variable and you cannot change it in the future. The type is strict and as long as the variable lives, it has this only one type. And the second thing that goes hand to hand with the static typing is that the compiler helps us here and compiler performs various checks and verifications on these types. For instance, if you're performing an assignment, then the compiler will verify that the left side and the right side are compatible at the type level. That's very important for this type of languages, for statically typed languages, because they can eliminate a lot of programmer errors during the compile time. That's very helpful because if you eliminate errors at compile time, you don't get them in runtime, right? So it's very, very useful. Why are we using CC for this type? Of course, basically because C&C actually I'm not going to make many distinctions between C&C in this course is that they are very, this language is very close to hardware. It's very close to the instructions. You can, you can easily map a regular language constructs into the instructions that will be executed on the CPU. You can directly map the structures, data structures, how they will, how they will be laid out in memory. And that's also very important. So C, it's very important in the tasks where you need this level of control. For instance, if you're programming the core, the kernel of an operating system, you need the full control over your hardware. If you're programming high performance applications and you need to fine tune your optimizations, then again, you want to be in control to know which instructions will be issued to the CPU. Or if you're working with embedded systems, usually embedded systems also require this. If you're programming, I don't know, washing machines or something, then you really need to know how to code on this level. The price that we pay for that is explicit memory management. So everything you do with memory you do explicitly, you need to be in control in where and variable where a data structure becomes, becomes alive when it, when it's allocated and when it's disposed, when you you need to dispose it explicitly. So that's the level of control you have, but also the responsibility you need to take in this kind of language. And like many languages, this language is case sensitive. There, there is no surprise there. But another important difference from Python is that it ignores all white space. In Python you already know we have something which is called a significant white space. So white space matters. How you indent your code matters because this is the way how you create blocks, like if blocks or function blocks in C++, you don't do that. This way we have other constructs and the white space is completely ignored. However, by the way, if you already learned how to indent your code in Python, do it in C as well. The notion that you need to indent your code in Python isn't a bad notion. It's like a good idea to indent your code because it's much more readable. You just don't have to do it the exact way in C, but keep doing it if you already learned that in Python. So I told you that the most important difference between Python And C is the typing system. So let me elaborate on that for a while. OK, first of all, in Python you can rewrite the value of the variable, not only the value, but even the type of a variable. So if you have have a variable that is assigned an integer and sometime later it's assigned a string, that's fine with Python. Well, it may may not be fine with your code design. There are very few situations in in your life when you really want to do that. Because if you already have a variable and you assume that there is an integer in this variable, it might not be a good idea to just suddenly assign a string into it, right? But you can do it from the Python Python's perspective. In C you cannot. So if you tell the compiler that there will be an integer in this variable, there should be an integer. And if you try to put there anything else, it will blow up in your face at compile time. So the compiler will say, hey, I'm not going to compile this code. This code sucks because you're trying to assign a string into an integer, and I'm not happy with that. So no, no can do. And the compiler will not produce the binary, so you cannot execute this code. So basically if you just take a step back, one perspective how you should look at these variables is that in Python or similar languages, in dynamically typed languages that the same goes for PHP or JavaScript for instance, is that variables are just mnemonic holders, are just labels, names for the programmer that are associated with values that live in some magical heap somewhere in the memory and are automatically managed and can be anything. So you can relabel, you can attach a label the same label, one to the string, 1 to the string, another time to an integer, a third time to a list. It doesn't matter. In C and statically typed languages it goes also for C or Java for instance. The variables also allocate space. So the variable isn't just a label, it's label of a memory space. That's why we need the type, because we need to know how many bytes we need to allocate for this variable. If it is an integer on a 32 bit architecture, it will be probably 4 bytes. So this NUM variable over here will actually tell the compiler, hey you should somewhere in the memory take 4 bytes and this NUM label refers to these 4 bytes specifically forever. As long as this variable lives, these 4 bytes in the memory will be associated with this variable. So you cannot possibly put there anything else because this string will definitely won't fit for four bytes, right? So you cannot easily assign it there. Yeah, there are some situations like if you want to insert assign 1 character into this into this variable. It might work because a character is small enough to fit 4 bytes. But still, the compiler will at least warn you that you are doing something very naughty and you shouldn't be doing that. So basically, remember in C++ variables are directly attached to place in memory where the value of the variable lives. A few words about the history of the language. So basically C is a very old language, you know, I believe nobody here was alive back when it was this started. I wasn't, I assume you weren't as well. So it started many decades ago in Bell Labs at the actually it started in Cambridge and then it was continued in Bell Labs. And they just wanted to create a very low level language because back then most of the software was written in assembly language and that that was horrible. So they need to something very close to assembly language, so something very close to instructions. So they still can code things like operating systems, etcetera, but they want something more pleasant to the to the programmer. So they tried to create first they created the BCPL language. They weren't very happy about it. So they created the B language shorten of the BCPL and they were still very happy about it. So they created the C language. Yeah, they weren't very imaginative about the language names, right. The C was quite popular for some time, and as you can see, it was revised. The specification of the language was revised several times, and now I think the last revision is from the year 18, so it's not that old from the perspective of, let's say, this diagram. On the other hand, the C is not very widely used language nowadays, but it still has its place. For instance, as I mentioned before, when you're writing a kernel of an operating system, the kernel of of Linux is still written in C, for instance. However, for regular use, for normal situations, for application programming, C isn't probably your first choice. Actually, it's probably not your second. And nowadays it's probably not your last choice either, because writing something in C is a pain in the *** if you really want to do something fast and you really want to do something fancy. So there were several attempts to introduce modern concepts, especially the object, object oriented programming concepts into C One of these was the Objective C It was for some time propelled by Apple, but it ended quite soon, quite quite some time ago, I wanted to say. So there was this is language called Objective C Probably you heard about it, but I think it's it's completely dead nowadays. Also, no sorry. There was the C with classes, but it was just a middle step to something which is now called C++. Actually the C++ back then and the C++ of today are completely two different C plus pluses. The the language took a huge evolution over this time. So basically this C++ has nothing to do with modern C++. C++ 23 for instance. However the evolution took place, there was a huge gap right in the between 90s and like 2011. This was like dark ages for C++ because many, many people back then thought that C++ will die because new languages like C# and Java sprung right alongside with C++ and Java and C# are for a long time believe that they will take over the application programming. However, C++ kind of resurrected itself around 2011 when the C++ 11 norm specification came out and this specification was very different. This was like one of the turning points of this language and since that every three years there is a new specification of C++. So yeah, sorry, this diagram misses C++ 23, which is the currently the most recent specification. And each of these specifications brought something new to the language. So it's a very complex set of set of changes. I'm not going into the details, just that, you know, if you want to code in modern C++, you really don't need to. You really don't need to bother yourself with the old versions. That's something which is all already completely outdated and thanks to these new features which were introduced since C++ 11, the C++ is still competitive in many domains to C# or Java. Let me start with a brief introduction of the syntax. Actually, if you can just read this, you probably understand what this code does, right? Because you already know Python, so this is not, this shouldn't be that surprising. The first line, the include line is somewhat like import. You already know import in Python. So we need to mechanism that will import libraries or import additional dependencies. This is somewhat different. It's just like a copies header inside. But for all instances and purposes of this class it's like import. So we we are importing a module C to the IO which gives us the function for printing out strings to the standard output. And the function we are using here is the print F which is similar to print in in Python. It's just a formatted print. But the difference is not that important here. So I believe you you can read what this function, what this line does, you can notice one important difference. There is a column at the end, semi column at the end. That's one of the important differences. We need to place; After every statement in in C++, Yeah, just yesterday I had some talk with my friends. Why are we now using semicolons? It's it's obvious where the line ends. So if we have just an end of the line like Python, why we need to place semicolons there? Yeah, it's a very, very old custom, but you need to realize that several decades ago the compilation time was one of the critical issues. And placing semicolons after every statement helps the compiler to recognize where actually each statement ends. So it was done mostly for the purposes of faster compilation. Yeah, today it's it's like obsolete because we can do it fast enough without the semicolons, but it's still in the language specification. And perhaps the most important difference here is that you can see this is function declaration. You probably guessed that because this looks like a function. Yeah, it it likes the the prefix depth which you are used to from Python. This int is a return type. The function is declared starting with the return type, but then it's the function name and arguments which you probably could could have guessed. There is no top level code. There is there are no top level statements. Every code in C++ has to be placed in a function or a method. Imperative code of course. The reason for that is that C++ is like old school and you just need to decompose your code in. In functions there is one function special and then this is that one which is named main and the main function is the entry point of the application. So everybody knows that the main function is like the top level statement in Python. This is the function that will be called the 1st when you when you just execute your application, this is the function that will be called. These are arguments where the command line parameters are passed to the application. So if you add any command line parameters like additional arguments on the, they are parsed and put into these into these variables. I'm not going into the details right now. And this is the return code. Here is the exit code of the application. You probably know or you will learn in Linux courses that every application, every proceed, every process, when it ends, it yields an exit code. So this is the exit code we are yielding 0 usually stands for. So this is the basic structure of the language. Let me go through a few details because there are some nuances that you really need to know. First of all, let's start with numbers. Yeah, the similar numbers are. There are no surprises there. You know what the similar numbers are in C You can also write numbers in hexa format, which is prefixed with 0X, and then you can use all 16 hexa characters. It doesn't matter whether you're using uppercase or lowercase, it's fine both ways. And the same way you can use the binary prefix 0B and then you use only zeros and ones to specify your literal. There is one catch. There is also octal format, so you can specify octal numbers in eight base math and they are prefixed with zero. I don't know who actually come up with this, but I really want to meet that guy and tell him a thing or two because this is like a obstruction. If you if you ever happen to have a like an array of of these literals and you just smuggle in one octal literal inside, you just created a perfectly unmaintainable code because no one will ever spot that this particular number is octal. It looks almost as it's as it's that similar, right? The 0 prefix isn't something that stands out to. So please, good idea is not to use this octal format at all. Actually, you usually don't use it because if you're doing something very fancy, you either use hexa, or if you're doing something very low level, you might prefer to revert to binary if you're not using this SIM, of course. So octal is not very, very useful here. Yeah, floating point numbers, they are the same as in Python, no surprise there. Boolean constants are also all the same, they are lower case. Just know that you need to start them with true and false. Yeah, I know this is pain in the *** because when I'm switching from C like languages to Python And vice versa, I always make this mistake because you need to like, remember in which environment you are and write uppercase T or a lowercase T if you're writing true. Yeah, I know that it's a pain in the *** but I blame Python people for that. OK, string and characters. There is a big difference because in Python you can write strings both in quotes and in apostrophes, right? In single or double quotes in C&C&C there is a difference. Apostrophe single quote stands for a character. So here could be only a single letter. Actually there must be a single letter. You cannot write an empty string this way. You need to write exactly 1 letter inside because this is a character. The double quotes, normal quotes stand for string, so here can be arbitrary number of letters or even 0 letters for empty string. So that's kind of a pitfall Python people usually fall into in the characters and strings. You can use some escape sequences to place in special characters. For instance, if you want to place a double quote into the string, you need to prefix it with a back slash so it's inserted as a double quote, not as the end of the string. OK, regarding the integer types, those were literals. Literals like numbers you just drop in your code. Integer types are somewhat more perplexing in C++. First of all, let me start with the most basic type, int integer. Unfortunately integer doesn't have fixed size, meaning the size is inferred from the platform on which your code runs. So if you take the same code and compile it for regular X86 laptop like you you probably all have, then it will have probably 32 bits. If you take it and compile it for Arduino, it will have 16 bits. And it's possible that from some other platforms it might have a different number of bits or bytes. So you really don't know how large the integer is. The dorm says that integer should be the type which suits the computation engine you're running on the best. So usually it's about 32 bits, but you cannot rely on that. On the other hand, character is always one byte wide. character is always one byte. That's pretty easy. And these base types like care or integer can be modified with modifiers. These are modifiers that change the width. So you can have a short int, long int and long long int, which suggests the compiler that you need to narrow down or widen your number. But then again, the compiler will just do what they do on that specific platform, so you have no guarantees that the like the long is larger than int. On many platforms long and int are the same. Usually long long is longer than in. So on X86 for instance long long X64 bits long and in is 32 bits long and other modifiers are signed and unsigned. Sign is like a default. You don't have to write signed, but if you want a number that doesn't go to the negative values, you probably want to use unsigned because then you are using values from zero to the full length of the of the number. Just remember how these numbers are defined. If you have like a 32 bit number for instance, then sign integer goes from -2 to the 31 right to 02/2 to the 31 -, 1 right? Did I do that correctly? While if you Yeah, while the unsigned goes from zero to 2 to the power of 32 -, 1, all right. So actually you have a wider range, the upper limit if you use unsigned. If you don't need the lower numbers, sorry, no, you need to, you need to split the range in half. So instead of this may be -1 or so is it -1 No, it's not. So if you need both negative and positive numbers and you have 32 bit range, then you need to like take a half of it, which is 2 to the power of 3132 -, 1. It's half of the range that goes for the negative numbers. And then you need to squeeze 0 somewhere. So the zero is squeezed to the positive numbers. Some, some person decide that zero is like a positive number, so 0 towards the positive numbers. But there, there will be only 31 because we don't have the range. We spent half of the range already for the for the negative numbers. No, no, no problem. If if anything isn't clear, ask away. That's why we're here. So basically you you can switch between the sign and unsigned arithmetics using these prefixes. There are also some accelerated types like size T Size T is a type which is wide enough to place any number for counting. So basically if you're using containers or try to index arrays, size T is your is your best choice. Floating numbers have two formats. Float is usually 32 bit wide and double is 64 bit wide. That that's something you probably already know. And there are some other types. Yeah, bool has no surprise you. You know bool from from Python, but there is one special type called void. Void is something like somewhat like none in in Python, but not not exactly. Void is a placeholder. We we put when there is no type to specify. For instance, if you have a function and that function doesn't have any return type, doesn't return anything. It's like a procedure. It doesn't have any anything to output. Then you declare it with void, which says OK, this This is like a no type. Nothing is returned. Compiler performs for you some implicit conversions. For instance, if you're trying to write to take a long integer, and you're writing into the integer, that's basically a conversion. Because these two types are not directly compatible, they are not exactly the same or they can differ in some way. So basically compiler will perform all these cooperations for you if they are possible. And whether they are possible, there is one big rule. There should be no data loss. If there is no data loss, then there is no problem. If you have a larger integer and you want to write in a small integer, that's fine because small integer will fit into the larger integer. Vice versa, it won't work if there is a possible data loss, but the conversion itself is possible. It will do the conversion, but it will issue a compilation warning. So the compiler will tell you, hey, I've noticed that you're doing this and I'm not completely certain whether this is OK. I will do it for you, but beware, you are you might have a mistake here. It's possible that this is a mistake, so double check your code. Normally warnings are bad. You shouldn't produce code that generates warnings on compilation. And I think from the third assignment we will enforce no warnings in in the record X. So just get used to the warnings and eliminate them from your code if you if you can. For instance, if you try to if you take a double and you try to assign it into the float, that's something which is possible because they are both floating point numbers, but there may be a data loss. So the compiler will allow that assignment, but will issue a warning that you shouldn't probably do this. At least you shouldn't do this lightly. You should do some checks before and you should do this explicitly to tell the compiler that this operation is fine. Yeah, there are some rules for this. For this conversions, there's something called conversion rank which computes what's the base type, etcetera. This, this is used in in a complex expression, but I'm going to skip that for for this time. OK, Sometimes these conversions needs to be done explicitly. You need to tell the compiler that that some operation needs to be done or that's OK to perform some of these conversions. For that we have casts. So you can cast one type into another, another type. It's like magic casting is easy. You just specify the new type in the parenthesis before the expression that needs to be casted. So if you have expression, or in this case just a simple variable that's also an expression, then you can convert it to another type just prefixing with the new type. Yeah, So we have a double and here the double is forcefully casted into a float. The compiler won't object to that because it's fine to convert double to float, it's technically possible. And also by specifying this conversion, compiler thinks, OK, the programmer really knows what he's doing or she's doing. So I will do that without objections. On the other hand, use that wisely, because it's not. It's not OK just to fix your warnings or errors by placing random arbitrary casts. You really need to like, check or notice, or sometimes even check using like if statements, whether this conversion is possible or whether it's safe within your code. By the way, this is how C casts work. In C++ the situation gets much more complicated. This is just a look ahead. I'm not going into the details right now, but just telling you that there are three types of casts in C and the things got much more mangled together. So I'm not going into the details regarding all the C versions and we won't need them. This works in the C fine as well, so use just this type of conversion and we'll be OK. So we talked about expressions, types and variables and now it's time to talk about variables. As I mentioned, variable is something that labels a place in the memory. Variable must be always declared using a type, and then there's the name of the variable. By the way, usually the variable is not initialized. Some variables are like global variables, but local variables are not initialized automatically. So it's usually a good way a good idea to initialize the variable right away because then you that there is no mistake. If you do this, then there will be 0 in the X variable from the from the very beginning and no one can ever make a mistake about using some arbitrary numbers for instance. By the way, there is also a special keyword called auto. You can use auto to declare variable and then the type of the variable. Here will be inferred, will be guessed, will be deduced from the type of the expression which is being assigned to the variable. OK, so sometimes it's easier, especially if you have some complex types. If you're working with classes or templated classes and you have some long types to write, then you can just put 4 letters there, auto, and the type will be inferred automatically. On the other hand, handle this with extra care because it's not a good idea to place auto just for all your variables. This is not Python. You really need to be in control what the value, what the type of the variable is. And sometimes, for instance here, it's fine because this is clearly double. Float literals are specified slightly differently, but if you just place a zero in the variable, then it's difficult to guess if I have something like this. If I have just a auto X = 0, what's the type of X? Why, Why, why? Why isn't it it's zero? Why isn't it unsigned integer? Why isn't it long? Why isn't it long long? Yeah, you're right. You're right. By the way, it will be integer, but it's difficult to guess sometimes. And if you just this is 0, this is fine, but you can just place a larger number here, and based on the larger number, it might try to use a larger type sometimes. So it's always better if I specify explicitly. Yeah, that's just the normal unassigned integer, and everybody's clear about that. By the way, writing int is shorter than writing auto, so there's no save there. There is something which is called a variable scope. You already know that from Python on a limited basis because in Python you have local variables and global variables, right? You have variables within functions which are local, and then you have a global variables. The same thing goes in here. So we have local variables, but they don't exist only within a function. They actually exist within a block. So any block, anything that's placed in the curly braces, usually it's one function, but it can be just a statement, like a body of an if statement. So the local variable lives only within this block. And of course the nested blocks of this block, it goes this way. But once you leave the block, the local variable will be de allocated and it's no longer accessible. Global variables are the very same like in Python. But in Python you need to use the explicit global word if you want to access global variable within a function, right? Everybody remembers that in C you don't. That's why C is much more error prone when you're using global variables, because sometimes you just need to think whether the variable you are accessing right now is local or global. There is no distinction. There is no global keyword, so usually accessing global variables directly from a function is a bad idea. We will get to that throughout the course. Actually, you will get that in the labs throughout the course. I'm not going into that, but basically global variables are bad in many situations. There is also something called static local variables. These variables are similar to global, meaning that they live throughout the existence of the program. This actually they start to live when you first call a function because they are inside a function. But they live till the end of the application. They are not erased when the function call is returned. So the difference is that the static variable is encapsulated, is wrapped in the function, cannot be accessed from outside, which makes it much more, much less error prone, because you wouldn't accidentally or incidentally access this counter from outside. If you have a global variable, that's very tricky, because everybody can access the global variable. Someone can just accidentally or by mistake erase it, rewrite it, update it, whatever. Let me go quickly through the statements. I'm not going into too much details because I believe you know all the statements. So I'm just making the comparative analysis toward the Python so that just pointing out the pitfalls so you easily slip into this into the coding. First of all, I only mentioned this several times, so let me do this properly. This is a block, every statement block which needs to be compound together like a function body, like a body of a for loop, like a body of a if branch needs to be wrapped in this curly braces. As as I mentioned at the beginning, it's a good idea to indent the code inside this curly braces. So don't forget your good manners from Python. The thing that C doesn't enforce indentation doesn't enforce specific white space formatting doesn't mean that you shouldn't do that. It's actually a good idea to do that, so the compiler will recognize these, but you, as a normal people still do the indentation. It's a good idea. Second thing, semicolons after each statement. I already mentioned that if statements and similar statements are different in a small way. The expression that's being tested in the branch is wrapped in the parenthesis and there is no column at the end. So that's how we know where the expression ends. It's it's wrapped in the parenthesis, but otherwise the if else statement is very similar to Python And return is also the same as in Python. There are no surprises there. One thing that's slightly different or not slightly not that slightly, is a switch case. If you have many branches, like many if elses, I mean like many if else if else if, then it's probably a better way to wrap it in something different. The switch case allows you to test one expression towards several possible outcomes. So this may be a variable or a computation that yields a number, an integer, and here are possible values that will be matched against this expression and each case will perform will have a block. Actually this is not a block, this is a sequence of of statements which needs to end with a break. The break will end the switch case and yields the control at the end of the whole switch case block. So basically this is like a huge if else case, a huge compound of if if else's and compiler can optimize it more slightly better than in just a simple switch case code or if else code. Also sometimes this might be slightly more readable because you can aggregate these cases together. If you don't have the break, then this case will fall out through this case. So case two and three will have a common, common body. On the other hand, one thing that I'm, let's say, emphasizing a lot is that every time you're writing a switch case, you probably want to rethink your life. Oh, sorry, your code because branching, heavy branching is usually bad. Many people, usually beginners, tend to write this if elses, like yeah, and I'm just now I'm meeting a new H case of my code which I haven't thought of before. So I'm just putting another if else there so we can take care of another special case. That's not the way it works. That's not the way it's supposed to work. It's a good idea to keep branching to minimum. Especially, it's a bad idea to have nested branching. If you have like more than two levels of nested branching, that's usually very bad. So if you're doing something like this, rethink your ways. Rethink your design. You probably want to do something else. You probably want to go about the code decomposition, about the coding another way. I personally find like 2 cases. One switch case was a good idea in C and I've been doing this for 25 years, so please take my word for it. Loops are quite easy. Yeah, they are similar to to Python. The while statement you already know right? There is an inverted statement called called do while. If you don't remember these two, there is a good sorry there is a good illustration 8 that will explain the difference between these two. So this one will perform the testing expression first. So it will first ask whether it's OK to execute the body. And if it's OK, then it executes the loop of the body, the body of the loop. The other one will first shoot away and perform the statement, perform the body, and then it will ask whether it was OK or not. Actually, it asks whether it's OK or not to continue with with that. So yeah, there are cases when you really want at least one iteration of this loop to to be to take place. So in this in that case do while might be better, but in 99% of situations the while loop is is the loop of choice. There is another loop called for loop and that is quite different to Python. In Python, the for loop is more like for each. You're providing a list or an iterator or a generator or something that will the for loop iterate over. This is usually more more suitable for the programmers because you usually want to use for loops to iterate over and container. You have a list and you want to visit every item in that list. So you basically write a for each that visits every item in the list, and the loop is invoked for every item in the list that it's perfectly clear to everybody, it's easy to use and everything. Unfortunately, C was designed much before this concept, much further in the past before this concept. So basically they go to about the four loops in another way. loop has three expressions and these expressions are performed at the beginning as a test before each loop, as at the end of each loop. What does that mean? Let me give you an example of this. It makes it much more clear. The first statement, the first expression is initialization. Usually you want to declare a variable which governs the loop, which is like a control variable of the loop. It's like if you're iterating over a list, this would be a variable that each list item is assigned in Python. But here we don't have that. So we use numbers and this is like a number that counts which iteration we are in. The second expression is the condition. This is the same as a condition in the wire loop. So this is tested before every loop starts. So we are iterating unless the I exceeds N As long as I is lesser than N we are proceeding with the iteration and the last. The third expression, this one is performed at the end of each loop. So basically this is usually an update of the governing of the main of the controlling variable. So in this case, we are incrementing it. This loop will go from zero to what would be the last value of I during the last iteration and -1 Exactly. Yeah, because once AI reaches N then there will be no more loops. By the way, the I is declared here, so it will live only within the loop. If you try to access I after the loop, it won't exist. So you can rewrite your code if you need to, but it's not a good idea. Just to give you an example, is there any reason why plus plus I is I plus plus? Yeah, there is a reason for that. And I will get to that when I'm talk, when I'll talk about pre and post increments. So yeah, there there is a small tiny reason for regular use. It doesn't matter. Yeah, but but there is one small tiny difference. I will mention it later. Yeah, I want to say that you can place this integer outside the loop. You can, you can place it before the loop. Technically it's possible. Usually it's not a good idea to do so, but then the eye will exist after the loop. What would be the value of I once the loop concludes? When the control resumes after the loop, what would be the value of I if we declare it beforehand? We already established that the value of I will be n -, 1 in the last iteration, Last time this body. Sorry, we have some trouble with shades. Yeah, embrace the darkness. So this loop, this body will be last executed with n -, 1. What will be the value of I after the last loop? And exactly because it will be incremented at the end, so it will reach the value N then this test will take place determining that it's time to end, but the value N will remain in the variable. But remember this was just an example. I just wonder whether I will be seen on the camera when I just when I put the shades down maybe? I'll figure it out later. So that's about it. About the basic statements, there is one statement I haven't mentioned yet and that's go to, go to is a very sorry go to is a very special statement because it somewhat disrupts the nature of workflow of the other statements. So basically we can use it to just take up and go somewhere else immediately. In this case, if this condition holds, the go to will completely jump out of all the loops and go over here where the label is. This has a very few good use cases like this one if you have a heavily nested code. If you have many for loops inside and you want to suddenly jump out all of them, then there's no other way how to do this except for go to, because if you use constructions like break, it breaks only one loop, not all of them. On the other hand, if you're using go to, beware that go to is usually. In many cases it's a bad practice, so try to avoid go to. This is just that you know that go to is there. By the way, go to is also usually frowned upon by experienced programmers because usually you can express yourself better without go to. By the way, there are many parodies on go to like if you know intercolor language, it uses come from like inversion of go to. So imagine that go to is somewhat disconcerning regarding the readability of the code. Then come from is even more disconcerting because if you use come from, the code is even more unreadable. It's it's it's even more mess. Few words about operators. I think that wasn't that good idea. Let me try no. I think this would be a good compromise. The Sun was going from this side I believe. OK, the arithmetic operators are quite the same as in Python. Just know this is modular. I'm not sure if what's the code for modulo in Python right away. So this is modulo arithmetics. Just beware single slash is division, but double slashes are used to initiate A1 line command. So this is sometimes a little little confusing. And these two plus plus and minus, minus are called called a pre and post increment or decrement. And there was a question What's the difference between pre and post increment or decrement? So let me give you an example. On the code previously shown, I have a plus plus I. Semantically this is equivalent to I = I + 1. Or you can write it as I + = 1 both in Python, right? That's easy. I plus plus can be also written as plus plus I can be also written as I plus plus. The difference is that this increment takes place before anything, and this increment takes place after anything. If you just use these as a statement alone statements, there is no difference semantically. But if you use these in a large expression, then the difference is that here the I is incremented first and then the incremented value of I is used in a subsequent expression. Let me demonstrate. Let's just say I use I plus plus something like y = I + + + X for instance. And here I write y = I + + + X looks almost the same. But here the I will be incremented first and then it will be added to X. Here the value of I will be taken, put aside, add it with X and afterwards the I will be incremented. That's basically the difference. Piece of advice, especially for beginners, don't write code when you need to make this distinction. So basically, if you really, really don't need to, and beginners don't need to, believe me, just use these as a separate statement and then they work the same. You don't have to make any distinctions. If you really need that, you need to remember this rule I just told you, and sometimes it's a bit bit disconcerting. So please make sure that you're happy with your code. And if you're not certain, just use these as a single statement, as a single expressions and it will work fine. Another thing are comparators. Yeah, comparators are almost the same as in Python. Beware that the comparison of equality is 2 = a single equal is used for assignments. That's like how they are distinguished. The exclamation mark is used for negation on many on many places. For instance, it can be used as a logical negation as a standalone unary operator here. When combined with equality mark, then it's it's like a negation of equality test. So this is like not equal. This is equal. This is not equal. What's perhaps the most important for us in C++ is bitwise operations. We will use them quite a lot. When you get to quite a lot, we will use them in the labs. And these bitwise operations stand for logical operations performs per each bit. For instance, the & stands for and. So if you have something like X&Y, it means that it takes these two numbers and end them bit per bit. So if you have something like 01/01 etcetera, 1100 that it will really take each bit separately and only because this is end, only the bits where both values are one will be set to one or other bits will be set to 0, right? Everybody remembers basic logical operations from the first semester. Is that so? OK, at least a few people are nodding, so I hope so. The same goes for OR. This is OR operation. The pipe is OR operation. These are somewhat more perplexing. This is bitwise negation. So this is like a flipping of all the bits, zeros to ones and ones to zeros. And this is exclusive OR or. The last two are bit shifts. Sometimes you need to move the bits in your word to the left or to the right. So for instance, if I take something like X left shift, this is like really like an arrow. Yeah, this is lesser than, lesser than, but it looks like an arrow. So it's called left shift, let's say 2. It will perform this operation that the let's just imagine that there is a 0100 something something 11101 this is the X value OK after shifting it towards left, it will all the bits will move so that there will be two zeros on the right and then I will start copying this value. So one will go here, 0 will go here, one will go here, etcetera, etcetera. And at the end, these two zeros will be the last values on the left. And these two values, these two bits will be thrown away because there is no more room in the in the in the integer for them. OK, so this is a left shift. Right shift works analogically on the other way, the other way to the right. These are actually quite important, because what is if if I take a normal integer like X and I shift it by two to the left, What arithmetical operation? This is equivalent with multiplying by 4 exactly, because shifting by one bit is multiplying by two. Shifting by two bits is multiplying by 4, two to the power of 2? By the way, there are other logical operators, two ampersands and two pipes and. The difference is these are performing these miracles on the bitwise scale on each bit in an integer. These are logical operators. They take two booleans and perform whatever logical operation they are doing. So they take true and false for instance, and the result of true and false will be in this case false. So these are to be used in a conditions. If you're writing an if statement and you need to combine 2 conditions to 1 using and or or using basic logic, then you use these. This is a negation. If you're doing something low level with your bits in your, in your integers, in your words, then use these. OK, That's the distinction. OK, Pointers. Pointers are somewhat difficult. We have two operators for pointers. Yeah, it's confusing. This is an ampersand, which you already seen here and here. Yeah, at least there are two of them here. So this can be really a parsed out. You can really differentiate this this one out. But this and this are the same operators in the terms of syntax, in the terms of literals, in the terms of of tokens. So basically, if you write an ampersand, the compiler needs to distinguish whether this is this & or this one. Fortunately for us, this one is a binary operator. It needs 2 operands. This one is a unary operator. It takes only one operand on the right side. So basically this is the distinction that the compiler needs to make. And this & is to take an address of a variable. So it converts a variable name into the address in the memory. We will use it later. Actually we will use it next next week because we won't get to pointers this this session. And* is also somewhat overloaded operator because we have* here as a multiplication operator, right? But fortunately for us, again, this is binary operator, this is unary operator. Asterisks are used to declare and to dereference pointers. So these two I will explain in more detail later when we get to references and pointers. Yeah, just to note that normal assignments doesn't have to be explained, but like in Python, we have shorthand assignments like plus, equal, minus, equal, etcetera, which combines together the explicit binary operation and assignment. So as I mentioned before, if you write something like I + = 1, it's the same as if you write I = I + 1. It's just to safe, safe typing, nothing else. One important operator that you will read right away in the labs is the size of operator size of It's very practical because it gives you at compile time number of bytes. A variable or a type or a data structure takes in the memory. So if you write something like size of int, it will tell you what is the size of integer variables on your particle architecture. So you are not completely lost in the river without a pedal. Regarding the sizes of the types you have at least something you have the size of. That will tell you what is the actual size on the architecture which is currently being used there. For the compilation of the int variable, usually it would be something like 4. On Arduino it would be two. For instance you can instead of type, you can write here a variable. So if I have a variable like I, I can just write here I and that's it. It will give me the size of this variable based on what type this variable is. And finally, last expression I want to show you is the ternary expression. Actually this is in Python as well. I'm not sure if you meant it in C it's much more compact than in Python. This is like a somewhat like a if branch, if else branch. This is the testing condition for the branching. This is the result which will be taken if the test is true. If the result of this expression is true and this will be taken. This will be yielded if the result is false. So basically you can use it to shorthand simple if else cases if you don't have to write any code or any complex code. In the if else case you just need to yield 1 value if something is true, another value if something is false. Then you can use this shorthand which is much more compact, much much more pleasant for in many situations if you just dealing with a simple simple expressions. By the way, does anyone know how to write this in Python? You meant that in Python the ternary expression. Basically, you write some something, then if The thing is true, then you write else and exactly. So you write E1 if then there is the test else. Sorry, I took a wrong piece of blackboard else E2. Yeah, that's very, very confusing. So see like which is have it slightly better and much, much shorter because you don't have to write the if and the else. OK, that's it about the expressions. And now we are finally meeting our most important nemesis of today and that are arrays. I've intentionally planned the arrays on that point because we will end with the arrays and next week I will just remind you about the arrays so we can pick up on them easily. Arrays in C have some small distinctions from lists in Python. The most important difference is an array have one specific type of items. So basically you declare a base type, the type of every element, and then you cannot deviate from this type. So if you have a list of integers, all the items array of integers, all the items are integers. In Python, if you have a list, you can put integers, floats, strings, whatever you'd like, or even nested lists as you please. You don't have to declare that beforehand. In C++, you need to say this is an array of integers and nothing else but integers can pass in This is an array. Then only floats can can be stored in. The arrays are declared using the brackets and usually you write the number inside the brackets. This way we declare something which is called statically allocated array. So we have a fixed number of items that will be stored that can be stored in this array. It's not dynamic like enlist in Python that you can just simply add more items there. It will always have just 4 items in this case. Yes, we can do this dynamically. We can do dynamic allocation, but that's much more tricky in C and we won't do it in this course. We're just deferring it to the second year. Yeah, It's not because it's like we don't want to give you that opportunity. It's just because it's too difficult to perform in C because you need to allocate and reallocate the memory manually if you're doing something like that. And we have no time for that in this course. So another way how to initialize statically allocated array is by initializer you can specify the numbers or the values that will be immediately stored into the array. And in here the size of the array. You can see that I have omitted the number that specifies the size is inferred from the initializing structure. So the compiler will deduce that since there are three integers over here, then the array should have three slots. The array should have the size of three integers. By the way, you can write the three in here if you'd like, but usually it's not a good idea if you're initializing it. It's like a redundant information. If you want to later change that, it would be more tedious because you need to change two things, the initializer list and then this number. So it's easier just to hope that the compiler will do its job and compute the right number of integers in the initializer. And we can trust compiler that at least it can do that. The arrays can be nested. This is like A2 dimensional array. Actually it's linearized in the memory. I will get to this in shorthand. This is like an initialization of two arrays of three array of three item. Sorry, two arrays of three integer arrays. Yeah, I get a little stuck in the terminology. So basically the first dimension first the dimension is size of two and the second dimension is size of three. And this array is linearized in the memory so the values are still stored one after another. This is like just a shorthand for indexing all. An array is always a compact block in the memory. That's one of one of the important things of arrays you need to learn in C, because if you have 4 integers, they will be in the memory write 1 after another. You can if you just have a pointer to the beginning of the array. You can easily compute any offset of any item position of any item just from from the offset. That's why this is done. So here the two-dimensional array is still laid down sequentially. There is just you need to remember which dimension is the first. So the increment goes from the end. 1st we incrementing the last dimension when we moving towards the memory. Then once we are through with the second dimension, we will increment the first dimension. You don't have to remember that by your heart. Actually, this is like a just to show you how the linearization works. But to be completely honest, every time I'm using the statically typed aesthetically allocated 2 dimensional arrays, I need to look this up because just to make sure that I won't make a mistake. Usually we don't do that. OK, and I think this is a good place to stop right away because, yeah, next time we we pick up on arrays and I will introduce how the arrays are used for strings and other stuff. So yeah, we have some spare time, but I believe we can we can quit 5 minutes early. Are there any questions regarding this course, regarding the labs or regarding the C++ language whatsoever? Will we get any homework from the lectures or just the labs? You you want some OK, you can. So this guy wants homework so you can, you can beat him up later, OK. No, no, no, no, no. There, there will be no homeworks from, from, from lectures. The lectures are theoretical. And believe me, the only homework would be to, let's say, learn everything for the exam that that's enough. Just just do your homeworks in the labs that that will be that that will do nicely. If there are no more questions, thank you for your attendance and we will meet next week.